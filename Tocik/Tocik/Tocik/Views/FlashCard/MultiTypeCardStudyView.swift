//
//  MultiTypeCardStudyView.swift
//  Tocik
//
//  Created by AI Assistant on 2025/10/23.
//  v4.0 - Â§öÈ¢òÂûãÈó™Âç°Â≠¶‰π†
//

import SwiftUI
import AVFoundation

struct MultiTypeCardStudyView: View {
    @Bindable var card: FlashCard
    @StateObject private var tts = TextToSpeech()
    
    @State private var showAnswer = false
    @State private var userAnswer = ""
    @State private var selectedOption: String?
    
    var body: some View {
        VStack(spacing: Theme.spacing.xlarge) {
            // Âç°ÁâáÁ±ªÂûãÊåáÁ§∫Âô®
            CardTypeIndicator(cardType: card.cardType)
            
            // ÈóÆÈ¢òÂå∫Âüü
            QuestionSection(
                card: card,
                onSpeak: {
                    if card.enableVoiceReading {
                        tts.speak(text: card.question)
                    }
                }
            )
            
            // Ê†πÊçÆÈ¢òÂûãÊòæÁ§∫‰∏çÂêåÁöÑÁ≠îÈ¢òÁïåÈù¢
            answerSection
            
            Spacer()
            
            // Êìç‰ΩúÊåâÈíÆ
            if !showAnswer {
                Button(action: { withAnimation { showAnswer = true } }) {
                    Text("ÊòæÁ§∫Á≠îÊ°à")
                        .font(.headline)
                        .frame(maxWidth: .infinity)
                        .padding()
                        .background(Theme.flashcardGradient)
                        .foregroundColor(.white)
                        .clipShape(RoundedRectangle(cornerRadius: 12))
                }
            } else {
                // Á≠îÊ°àÊòæÁ§∫
                AnswerSection(card: card)
                
                // ËØÑ‰ª∑ÊåâÈíÆ
                FeedbackButtons(
                    onRemember: {
                        handleAnswer(remembered: true)
                    },
                    onForget: {
                        handleAnswer(remembered: false)
                    }
                )
            }
        }
        .padding()
        .onDisappear {
            tts.stop()
        }
    }
    
    @ViewBuilder
    private var answerSection: some View {
        switch card.cardType {
        case .basic:
            // Âü∫Á°ÄÈóÆÁ≠îÂûãÔºå‰∏çÈúÄË¶ÅËæìÂÖ•
            EmptyView()
            
        case .fillBlank:
            // Â°´Á©∫È¢ò
            VStack(alignment: .leading, spacing: 8) {
                Text("ÊÇ®ÁöÑÁ≠îÊ°àÔºö")
                    .font(.caption)
                    .foregroundColor(.secondary)
                
                TextField("Âú®Ê≠§ËæìÂÖ•Á≠îÊ°à", text: $userAnswer)
                    .textFieldStyle(.roundedBorder)
                    .disabled(showAnswer)
            }
            
        case .multipleChoice:
            // ÈÄâÊã©È¢ò
            if let optionsData = card.options.data(using: .utf8),
               let options = try? JSONDecoder().decode([String].self, from: optionsData) {
                VStack(alignment: .leading, spacing: 12) {
                    Text("ÈÄâÈ°πÔºö")
                        .font(.caption)
                        .foregroundColor(.secondary)
                    
                    ForEach(Array(options.enumerated()), id: \.offset) { index, option in
                        OptionButton(
                            letter: String(UnicodeScalar(65 + index)!),
                            text: option,
                            isSelected: selectedOption == option,
                            isCorrect: showAnswer && option == card.answer,
                            action: {
                                if !showAnswer {
                                    selectedOption = option
                                    HapticManager.shared.selection()
                                }
                            }
                        )
                    }
                }
            }
            
        case .matching:
            // ÂåπÈÖçÈ¢ò
            MatchingQuestionView(
                card: card,
                showAnswer: showAnswer
            )
        }
    }
    
    private func handleAnswer(remembered: Bool) {
        // ‰ΩøÁî®SM-2ÁÆóÊ≥ïÊõ¥Êñ∞Â§ç‰π†Êó∂Èó¥
        let (newInterval, newEaseFactor, nextReviewDate) = SM2Algorithm.simpleReview(
            card: card,
            remembered: remembered
        )
        
        // Êõ¥Êñ∞Âç°ÁâáÊï∞ÊçÆ
        card.reviewCount += 1
        if remembered {
            card.correctCount += 1
        }
        card.lastReviewDate = Date()
        card.interval = newInterval
        card.easeFactor = newEaseFactor
        card.nextReviewDate = nextReviewDate
        
        // ËÆ∞ÂΩïÂ≠¶‰π†Êõ≤Á∫øÊï∞ÊçÆ
        recordLearningProgress(remembered: remembered)
        
        HapticManager.shared.success()
    }
    
    private func recordLearningProgress(remembered: Bool) {
        // Â∞ÜÂ≠¶‰π†ËøõÂ∫¶Ê∑ªÂä†Âà∞Â≠¶‰π†Êõ≤Á∫øÊï∞ÊçÆ
        let progress = LearningProgress(
            date: Date(),
            remembered: remembered,
            interval: card.interval
        )
        
        // Ëß£ÊûêÁé∞ÊúâÊï∞ÊçÆ
        var progressArray: [LearningProgress] = []
        if let data = card.learningCurveData.data(using: .utf8),
           let decoded = try? JSONDecoder().decode([LearningProgress].self, from: data) {
            progressArray = decoded
        }
        
        // Ê∑ªÂä†Êñ∞ËÆ∞ÂΩï
        progressArray.append(progress)
        
        // ‰øùÂ≠òÔºà‰øùÁïôÊúÄËøë100Êù°Ôºâ
        if progressArray.count > 100 {
            progressArray = Array(progressArray.suffix(100))
        }
        
        if let encoded = try? JSONEncoder().encode(progressArray),
           let jsonString = String(data: encoded, encoding: .utf8) {
            card.learningCurveData = jsonString
        }
    }
}

// MARK: - Â≠¶‰π†ËøõÂ∫¶ËÆ∞ÂΩï

struct LearningProgress: Codable {
    let date: Date
    let remembered: Bool
    let interval: Int
}

struct CardTypeIndicator: View {
    let cardType: FlashCard.CardType
    
    var body: some View {
        HStack {
            Image(systemName: cardType.icon)
            Text(cardType.rawValue)
        }
        .font(.caption)
        .padding(.horizontal, 12)
        .padding(.vertical, 6)
        .background(Theme.flashcardGradient.opacity(0.2))
        .clipShape(Capsule())
    }
}

struct QuestionSection: View {
    let card: FlashCard
    let onSpeak: () -> Void
    
    var body: some View {
        VStack(alignment: .leading, spacing: Theme.spacing.medium) {
            HStack {
                Text("ÈóÆÈ¢ò")
                    .font(.caption)
                    .foregroundColor(.secondary)
                
                Spacer()
                
                if card.enableVoiceReading {
                    Button(action: onSpeak) {
                        Image(systemName: "speaker.wave.2.fill")
                            .font(.caption)
                            .foregroundColor(.blue)
                    }
                }
            }
            
            Text(card.question)
                .font(.title3)
                .frame(maxWidth: .infinity, alignment: .leading)
            
            // ÊèêÁ§∫
            if !card.hint.isEmpty {
                DisclosureGroup("üí° ÊèêÁ§∫") {
                    Text(card.hint)
                        .font(.subheadline)
                        .foregroundColor(.secondary)
                        .padding(.top, 8)
                }
                .font(.caption)
            }
        }
        .padding()
        .background(.ultraThinMaterial)
        .clipShape(RoundedRectangle(cornerRadius: Theme.cornerRadius))
    }
}

struct AnswerSection: View {
    let card: FlashCard
    
    var body: some View {
        VStack(alignment: .leading, spacing: 12) {
            Text("Á≠îÊ°à")
                .font(.caption)
                .foregroundColor(.secondary)
            
            Text(card.answer)
                .font(.title3.bold())
                .foregroundColor(.green)
            
            if !card.explanation.isEmpty {
                Divider()
                
                Text("Ëß£Èáä")
                    .font(.caption)
                    .foregroundColor(.secondary)
                
                Text(card.explanation)
                    .font(.subheadline)
                    .foregroundColor(.secondary)
            }
        }
        .frame(maxWidth: .infinity, alignment: .leading)
        .padding()
        .background(Color.green.opacity(0.05))
        .clipShape(RoundedRectangle(cornerRadius: Theme.cornerRadius))
        .overlay(
            RoundedRectangle(cornerRadius: Theme.cornerRadius)
                .stroke(Color.green.opacity(0.3), lineWidth: 2)
        )
        .transition(.scale.combined(with: .opacity))
    }
}

struct OptionButton: View {
    let letter: String
    let text: String
    let isSelected: Bool
    let isCorrect: Bool
    let action: () -> Void
    
    var body: some View {
        Button(action: action) {
            HStack(spacing: 12) {
                // ÈÄâÈ°πÂ≠óÊØç
                ZStack {
                    Circle()
                        .fill(backgroundColor)
                        .frame(width: 32, height: 32)
                    
                    Text(letter)
                        .font(.subheadline.bold())
                        .foregroundColor(textColor)
                }
                
                Text(text)
                    .font(.subheadline)
                    .foregroundColor(.primary)
                
                Spacer()
                
                if isCorrect {
                    Image(systemName: "checkmark.circle.fill")
                        .foregroundColor(.green)
                }
            }
            .padding()
            .background(backgroundMaterial)
            .clipShape(RoundedRectangle(cornerRadius: 12))
            .overlay(
                RoundedRectangle(cornerRadius: 12)
                    .stroke(borderColor, lineWidth: 2)
            )
        }
        .buttonStyle(.plain)
    }
    
    private var backgroundColor: Color {
        if isCorrect { return .green }
        if isSelected { return .blue }
        return .gray.opacity(0.3)
    }
    
    private var textColor: Color {
        if isCorrect || isSelected { return .white }
        return .primary
    }
    
    private var backgroundMaterial: Material {
        if isCorrect { return .ultraThin }
        return .ultraThinMaterial
    }
    
    private var borderColor: Color {
        if isCorrect { return .green }
        if isSelected { return .blue }
        return .clear
    }
}

struct FeedbackButtons: View {
    let onRemember: () -> Void
    let onForget: () -> Void
    
    var body: some View {
        HStack(spacing: Theme.spacing.medium) {
            Button(action: onForget) {
                VStack {
                    Image(systemName: "xmark.circle")
                        .font(.title)
                    Text("‰∏çËÆ∞Âæó")
                        .font(.subheadline)
                }
                .frame(maxWidth: .infinity)
                .padding()
                .background(Color.red.opacity(0.1))
                .foregroundColor(.red)
                .clipShape(RoundedRectangle(cornerRadius: 12))
            }
            
            Button(action: onRemember) {
                VStack {
                    Image(systemName: "checkmark.circle")
                        .font(.title)
                    Text("ËÆ∞Âæó")
                        .font(.subheadline)
                }
                .frame(maxWidth: .infinity)
                .padding()
                .background(Color.green.opacity(0.1))
                .foregroundColor(.green)
                .clipShape(RoundedRectangle(cornerRadius: 12))
            }
        }
    }
}

// MARK: - ÂåπÈÖçÈ¢òËßÜÂõæ

struct MatchingQuestionView: View {
    let card: FlashCard
    let showAnswer: Bool
    
    @State private var matchings: [String: String] = [:] // Â∑¶È°π -> Âè≥È°π
    @State private var selectedLeft: String?
    
    // Ëß£ÊûêÂåπÈÖçÈ¢òÊï∞ÊçÆ
    private var pairs: [(left: String, right: String)] {
        guard let optionsData = card.options.data(using: .utf8),
              let decoded = try? JSONDecoder().decode([String: String].self, from: optionsData) else {
            return []
        }
        return decoded.map { (left: $0.key, right: $0.value) }
    }
    
    private var leftItems: [String] {
        pairs.map { $0.left }
    }
    
    private var rightItems: [String] {
        pairs.map { $0.right }.shuffled()
    }
    
    var body: some View {
        VStack(alignment: .leading, spacing: 16) {
            Text("ÁÇπÂáªÂ∑¶‰æßÈ°πÁõÆÔºåÂÜçÁÇπÂáªÂè≥‰æßÈ°πÁõÆËøõË°åÈÖçÂØπ")
                .font(.caption)
                .foregroundColor(.secondary)
            
            HStack(alignment: .top, spacing: 20) {
                // Â∑¶Âàó
                VStack(spacing: 12) {
                    ForEach(leftItems, id: \.self) { item in
                        MatchingItemButton(
                            text: item,
                            isSelected: selectedLeft == item,
                            isMatched: matchings[item] != nil,
                            isCorrect: showAnswer && matchings[item] == correctMatch(for: item),
                            action: {
                                if !showAnswer {
                                    selectedLeft = item
                                    HapticManager.shared.selection()
                                }
                            }
                        )
                    }
                }
                .frame(maxWidth: .infinity)
                
                // ËøûÊé•Á∫øÊèêÁ§∫
                Image(systemName: "arrow.left.arrow.right")
                    .font(.caption)
                    .foregroundColor(.secondary)
                
                // Âè≥Âàó
                VStack(spacing: 12) {
                    ForEach(rightItems, id: \.self) { item in
                        MatchingItemButton(
                            text: item,
                            isSelected: matchings.values.contains(item),
                            isMatched: matchings.values.contains(item),
                            isCorrect: showAnswer && isCorrectMatch(rightItem: item),
                            action: {
                                if !showAnswer, let left = selectedLeft {
                                    matchings[left] = item
                                    selectedLeft = nil
                                    HapticManager.shared.success()
                                }
                            }
                        )
                    }
                }
                .frame(maxWidth: .infinity)
            }
            
            // Ê∏ÖÈô§ÊåâÈíÆ
            if !showAnswer && !matchings.isEmpty {
                Button(action: {
                    matchings.removeAll()
                    selectedLeft = nil
                }) {
                    Text("Ê∏ÖÈô§ÊâÄÊúâÈÖçÂØπ")
                        .font(.caption)
                        .foregroundColor(.red)
                }
            }
        }
    }
    
    private func correctMatch(for leftItem: String) -> String {
        pairs.first { $0.left == leftItem }?.right ?? ""
    }
    
    private func isCorrectMatch(rightItem: String) -> Bool {
        matchings.contains { pair in
            let correctRight = pairs.first { $0.left == pair.key }?.right
            return pair.value == rightItem && correctRight == rightItem
        }
    }
}

struct MatchingItemButton: View {
    let text: String
    let isSelected: Bool
    let isMatched: Bool
    let isCorrect: Bool
    let action: () -> Void
    
    var body: some View {
        Button(action: action) {
            HStack {
                Text(text)
                    .font(.subheadline)
                    .foregroundColor(.primary)
                    .multilineTextAlignment(.leading)
                
                Spacer()
                
                if isCorrect {
                    Image(systemName: "checkmark.circle.fill")
                        .foregroundColor(.green)
                } else if isMatched {
                    Image(systemName: "link")
                        .foregroundColor(.blue)
                }
            }
            .padding(12)
            .background(backgroundColor)
            .clipShape(RoundedRectangle(cornerRadius: 8))
            .overlay(
                RoundedRectangle(cornerRadius: 8)
                    .stroke(borderColor, lineWidth: isSelected ? 2 : 1)
            )
        }
        .buttonStyle(.plain)
    }
    
    private var backgroundColor: Color {
        if isCorrect { return .green.opacity(0.1) }
        if isMatched { return .blue.opacity(0.05) }
        if isSelected { return .blue.opacity(0.1) }
        return .gray.opacity(0.05)
    }
    
    private var borderColor: Color {
        if isCorrect { return .green }
        if isSelected { return .blue }
        if isMatched { return .blue.opacity(0.3) }
        return .gray.opacity(0.2)
    }
}

